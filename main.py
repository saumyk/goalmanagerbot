# -*- coding: utf-8 -*-
"""Telegram Goal Manager Bot (main.py)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AgG2PD_yv5xsND52NL1tN1dI3OkU-l_B
"""

import logging
import os
from datetime import datetime, timedelta

from sqlalchemy import create_engine, Column, Integer, String, Boolean, DateTime
from sqlalchemy.orm import sessionmaker, declarative_base
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes

# Enable logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- Database Setup ---
# Use DATABASE_URL from environment for Railway PostgreSQL, fallback to SQLite for local development
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///goals.db")
Base = declarative_base()

class Goal(Base):
    """
    SQLAlchemy model for a user's goal.
    Each goal has a unique ID, is linked to a user, has text,
    a completion status, creation timestamp, and an optional due date.
    """
    __tablename__ = 'goals'
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, nullable=False)
    text = Column(String, nullable=False)
    completed = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.now)
    due_date = Column(DateTime, nullable=True) # Optional due date for the goal

    def __repr__(self):
        """String representation for debugging."""
        return f"<Goal(id={self.id}, user_id={self.user_id}, text='{self.text}', completed={self.completed})>"

    def format_for_display(self, index=None):
        """Formats the goal for display in Telegram messages."""
        status = "‚úÖ" if self.completed else "‚è≥"
        due_info = ""
        if self.due_date:
            due_info = f" (Due: {self.due_date.strftime('%Y-%m-%d')})"
        prefix = f"{index}. " if index is not None else ""
        return f"{prefix}{status} {self.text}{due_info}"

# Initialize database engine and create tables if they don't exist
engine = create_engine(DATABASE_URL)
Base.metadata.create_all(engine)
Session = sessionmaker(bind=engine)

# --- Bot Commands and Handlers ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Sends a welcome message when the command /start is issued."""
    user = update.effective_user
    await update.message.reply_html(
        f"Hi {user.mention_html()}! I'm your personal Goal Manager Bot. "
        "I can help you keep track of your goals.\n\n"
        "Use /add to add a new goal, /list to see your goals, or /help for more options."
    )
    logger.info(f"User {user.id} started the bot.")

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Sends a help message when the command /help is issued."""
    help_text = (
        "Here are the commands you can use:\n"
        "üìö /add <your goal> [YYYY-MM-DD] - Add a new goal. Optionally add a due date.\n"
        "üìù /list - List all your current and completed goals.\n"
        "üìÖ /upcoming - Show goals with upcoming due dates (next 7 days).\n"
        "‚úÖ /complete <goal ID> - Mark a goal as completed (you can find ID from /list).\n"
        "üóëÔ∏è /delete <goal ID> - Delete a goal (you can find ID from /list).\n"
        "‚ùì /help - Show this help message."
    )
    await update.message.reply_text(help_text)
    logger.info(f"User {update.effective_user.id} requested help.")

async def add_goal(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Adds a new goal for the user."""
    user_id = update.effective_user.id
    args = context.args
    if not args:
        await update.message.reply_text(
            "Please provide a goal to add. Example: `/add Learn Python` or `/add Finish report 2025-12-31`"
        )
        return

    goal_text_parts = []
    due_date = None

    # Attempt to parse a date from the last argument
    if len(args) > 1: # Only try parsing if there's more than just a single word goal
        try:
            # Check if the last argument looks like a date
            parsed_date = datetime.strptime(args[-1], '%Y-%m-%d')
            due_date = parsed_date
            goal_text_parts = args[:-1] # Exclude the date from the goal text
        except ValueError:
            goal_text_parts = args # No date found, so all args are part of the goal text
    else:
        goal_text_parts = args # Only one argument, it's the goal text

    goal_text = " ".join(goal_text_parts).strip()

    if not goal_text:
        await update.message.reply_text(
            "Please provide a valid goal. Example: `/add Learn Python` or `/add Finish report 2025-12-31`"
        )
        return

    session = Session()
    try:
        new_goal = Goal(user_id=user_id, text=goal_text, due_date=due_date)
        session.add(new_goal)
        session.commit()
        response_message = f"Goal added: '{new_goal.text}'"
        if due_date:
            response_message += f" (Due: {due_date.strftime('%Y-%m-%d')})"
        await update.message.reply_text(response_message)
        logger.info(f"User {user_id} added goal: '{new_goal.text}' with due date {due_date}")
    except Exception as e:
        session.rollback()
        logger.error(f"Error adding goal for user {user_id}: {e}")
        await update.message.reply_text("An error occurred while adding your goal. Please try again.")
    finally:
        session.close()

async def list_goals(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Lists all goals for the user with inline keyboards for actions."""
    user_id = update.effective_user.id
    session = Session()
    try:
        goals = session.query(Goal).filter_by(user_id=user_id).order_by(Goal.created_at).all()
        if not goals:
            await update.message.reply_text("You don't have any goals yet! Add one with /add.")
            return

        response_lines = ["Your Goals:"]
        keyboard = []

        for i, goal in enumerate(goals):
            response_lines.append(goal.format_for_display(index=i+1))
            # Add inline buttons for each goal
            keyboard.append([
                InlineKeyboardButton(f"‚úÖ Complete {i+1}", callback_data=f"complete_{goal.id}"),
                InlineKeyboardButton(f"üóëÔ∏è Delete {i+1}", callback_data=f"delete_{goal.id}")
            ])

        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text("\n".join(response_lines), reply_markup=reply_markup)
        logger.info(f"User {user_id} listed goals.")
    except Exception as e:
        logger.error(f"Error listing goals for user {user_id}: {e}")
        await update.message.reply_text("An error occurred while fetching your goals. Please try again.")
    finally:
        session.close()

async def upcoming_goals(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Shows goals with upcoming due dates (next 7 days)."""
    user_id = update.effective_user.id
    session = Session()
    try:
        # Get current date without time for comparison
        today = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        seven_days_later = today + timedelta(days=7)

        upcoming = session.query(Goal).filter(
            Goal.user_id == user_id,
            Goal.completed == False, # Only show incomplete goals
            Goal.due_date.isnot(None), # Only goals with a due date
            Goal.due_date >= today, # Due date is today or in the future
            Goal.due_date <= seven_days_later # Due date is within the next 7 days
        ).order_by(Goal.due_date).all()

        if not upcoming:
            await update.message.reply_text("You have no upcoming goals in the next 7 days.")
            return

        response_lines = ["Your Upcoming Goals (next 7 days):"]
        for i, goal in enumerate(upcoming):
            response_lines.append(goal.format_for_display(index=i+1))
        await update.message.reply_text("\n".join(response_lines))
        logger.info(f"User {user_id} requested upcoming goals.")
    except Exception as e:
        logger.error(f"Error fetching upcoming goals for user {user_id}: {e}")
        await update.message.reply_text("An error occurred while fetching upcoming goals. Please try again.")
    finally:
        session.close()

async def button_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handles inline keyboard button presses."""
    query = update.callback_query
    await query.answer() # Acknowledge the callback query

    data = query.data
    action, goal_id_str = data.split('_', 1) # e.g., "complete_123" or "delete_456"
    goal_id = int(goal_id_str)
    user_id = query.from_user.id

    session = Session()
    try:
        goal = session.query(Goal).filter_by(id=goal_id, user_id=user_id).first()
        if not goal:
            await query.edit_message_text("Goal not found or you don't have permission to modify it.")
            logger.warning(f"User {user_id} tried to modify non-existent or unauthorized goal {goal_id}.")
            return

        if action == "complete":
            goal.completed = True
            session.commit()
            await query.edit_message_text(f"Goal '{goal.text}' marked as completed! ‚úÖ")
            logger.info(f"User {user_id} completed goal {goal.id}: '{goal.text}'.")
        elif action == "delete":
            session.delete(goal)
            session.commit()
            await query.edit_message_text(f"Goal '{goal.text}' deleted.üóëÔ∏è")
            logger.info(f"User {user_id} deleted goal {goal.id}: '{goal.text}'.")
        else:
            await query.edit_message_text("Unknown action.")
            logger.warning(f"User {user_id} triggered unknown callback action: {action}.")
    except Exception as e:
        session.rollback()
        logger.error(f"Error handling callback for user {user_id}, goal {goal_id}, action {action}: {e}")
        await query.edit_message_text("An error occurred. Please try again.")
    finally:
        session.close()

async def unknown(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handles unknown commands."""
    await update.message.reply_text("Sorry, I didn't understand that command. Use /help to see available commands.")
    logger.info(f"User {update.effective_user.id} sent unknown command: {update.message.text}")

def main() -> None:
    """Start the bot."""
    # Get the bot token from environment variables
    TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
    if not TELEGRAM_BOT_TOKEN:
        logger.critical("TELEGRAM_BOT_TOKEN environment variable not set. Exiting.")
        raise ValueError("Bot token not found. Please set TELEGRAM_BOT_TOKEN environment variable.")

    logger.info("Starting Telegram Goal Manager Bot...")
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()

    # Add command handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("add", add_goal))
    application.add_handler(CommandHandler("list", list_goals))
    application.add_handler(CommandHandler("upcoming", upcoming_goals))

    # Add a generic message handler for /complete and /delete if used as commands
    # These are primarily handled by inline buttons now, but good to have fallback
    application.add_handler(CommandHandler("complete", lambda u, c: u.message.reply_text("Please use the inline buttons with /list or specify goal ID: /complete <ID>")))
    application.add_handler(CommandHandler("delete", lambda u, c: u.message.reply_text("Please use the inline buttons with /list or specify goal ID: /delete <ID>")))

    # Add callback query handler for inline keyboard buttons
    application.add_handler(CallbackQueryHandler(button_callback_handler))

    # Add handler for unknown commands (must be last)
    application.add_handler(MessageHandler(filters.COMMAND, unknown))

    # Run the bot until the user presses Ctrl-C
    logger.info("Bot is polling for updates...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()